/**
 * Extension to Fragment Lists to support post-processing effects on the fragments.
 * This follows the ideas of the paper "Smart Transparency for Illustrative Visualization of Complex Flow Surfaces"
 */

#ifndef ILLUSTRATIONBUFFER_HGLSL
#define ILLUSTRATIONBUFFER_HGLSL

//screen size
uniform ivec2 screenSize;

// Buffers+Images

//Head pointer to the entry in the list
coherent uniform layout(size1x32) uimage2D illustrationBufferIdxImg;
//Number of entries in the list
coherent uniform layout(size1x32) uimage2D illustrationBufferCountImg;

//data stored per fragment, 12*4=48 byte
struct FragmentData
{
    //the fragment depth
    float depth;
    //the depth gradient, needed to determine neighbors
    float depthGradient;
    //the alpha value [0,1] + 3*b_alpha (bitfield as in the paper)
    float alpha;
    //the color in 10/10/10 rgb
    uint colors;
    //the neighbors: -x, +x, -y, +y; -1 if not existing
    ivec4 neighbors;
    //silhouette highlight field (beta) + 3*b_beta, as in the paper
    float silhouetteHighlight;
    //halo highlight field (gamma) + 3*b_gamma, as in the paper
    float haloHighlight;
    //index of this fragment in the list, saves some memory access
    //TODO: only 8 bit are used, use the remaining bits for something else
    int index;
    //unused yet, TODO: use for normal comparison
    int dummy1;
};

layout(std430, binding=4) buffer illustrationBufferStorageIn
{
    FragmentData illustrationDataIn[]; 
};
layout(std430, binding=5) buffer illustrationBufferStorageOut
{
    FragmentData illustrationDataOut[]; 
};

// Helpers

uint compressColor(vec3 color) {
    uint c = (int((color.r * 1023)) & 0x3ff) << 20;
    c += (int((color.g * 1023)) & 0x3ff) << 10;
    c += (int((color.b * 1023)) & 0x3ff);
    return c;
}
vec3 uncompressColor(uint c) {
    vec3 color;
    color.r = float((c>>20) & 0x3ff) / 1023.0f;
    color.g = float((c>>10) & 0x3ff) / 1023.0f;
    color.b = float(c & 0x3ff) / 1023.0f;
    return color;
}

#endif