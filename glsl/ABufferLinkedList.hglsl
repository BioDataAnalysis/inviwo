/**
 * Fast Single-pass A-Buffer using OpenGL 4.0 V2.0
 * Copyright Cyril Crassin, July 2010
 *
 * Modified by Sebastian Weiss, 2017
**/
#ifndef ABUFFERLINKEDLIST_HGLSL
#define ABUFFERLINKEDLIST_HGLSL

//this is important for the occlusion query
layout(early_fragment_tests) in;

//Uniforms changed from the C++ side
struct AbufferParameters
{
    int screenWidth;
    int screenHeight;
    vec4 backgroundColor;
    uint storageSize;
};
uniform AbufferParameters AbufferParams;

//Macros (maybe) changed from the C++ side

//max depth of the chain, all others are discarded during the final rendering
#define ABUFFER_SIZE 16

#define ABUFFER_USE_TEXTURES 1
#define ABUFFER_SHAREDPOOL_USE_TEXTURES 1

#if ABUFFER_USE_TEXTURES
//A-Buffer fragments storage
//coherent uniform layout(binding=5, size1x32) uimage2D abufferIdxImg;
coherent uniform layout(size1x32) uimage2D abufferIdxImg;
#else
#error Buffer access not supported
//coherent uniform uint *d_abufferPageIdx;
//coherent uniform uint *d_abufferFragCount;
//coherent uniform uint *d_semaphore;
#endif


//TODO: remove hardcoded binding point
layout (binding = 6, offset = 0) uniform atomic_uint abufferCounter;
layout(std430, binding=7) buffer abufferStorage
{
    //x: previous chain element, uint, +1
    //y: depth, float
    //z: alpha, float
    //w: color, 10/10/10 rgb
    vec4 abufferPixelData[]; 
};
struct abufferPixel
{
    uint previous;
    float depth;
    vec4 color;
};


//Fragment linked list

#if ABUFFER_USE_TEXTURES

uint setPixelLink(ivec2 coords, uint val) {
    return imageAtomicExchange(abufferIdxImg, coords, val);
}

uint getPixelLink(ivec2 coords) {
    return uint(imageLoad(abufferIdxImg, coords).x);
}

#else

#error Buffer access not supported

#endif


// Pixel data storage

uint dataCounterAtomicInc() {
    return atomicCounterIncrement(abufferCounter);
}

vec4 readPixelStorage(uint idx) {
    return abufferPixelData[int(idx)];
}

void writePixelStorage(uint idx, vec4 value) {
    abufferPixelData[int(idx)] = value;
}

abufferPixel uncompressPixelData(vec4 data)
{
    abufferPixel p;
    p.previous = floatBitsToUint(data.x);
    p.depth = data.y;
    p.color.a = data.z;
    uint c = floatBitsToUint(data.w);
    p.color.r = float((c>>20) & 0x3ff) / 1023.0f;
    p.color.g = float((c>>10) & 0x3ff) / 1023.0f;
    p.color.b = float(c & 0x3ff) / 1023.0f;
    return p;
}

vec4 compressPixelData(abufferPixel p)
{
    vec4 data;
    data.x = uintBitsToFloat(p.previous);
    data.y = p.depth;
    p.color = clamp(p.color, 0, 1);
    data.z = p.color.a;
    uint c = (int((p.color.r * 1023)) & 0x3ff) << 20;
    c += (int((p.color.g * 1023)) & 0x3ff) << 10;
    c += (int((p.color.b * 1023)) & 0x3ff);
    data.w = uintBitsToFloat(c);
    return data;
}


// Rendering function

// The central function for the user-code
bool abufferRender(ivec2 coords, float depth, vec4 color)
{
    //coords.x=0; coords.y=0;
    //reserve space for pixel
    uint pixelIdx = dataCounterAtomicInc();
    if (pixelIdx >= AbufferParams.storageSize) {
        //we are out of space
        return false;
    }
    //write index
    uint prevIdx = setPixelLink(coords, pixelIdx+1);
    //assemble and write pixel
    abufferPixel p;
    p.previous = prevIdx;
    p.depth = depth;
    p.color = color;
    writePixelStorage(pixelIdx, compressPixelData(p));
    return true;
}

#endif	//ABUFFERLINKEDLIST_HGLSL